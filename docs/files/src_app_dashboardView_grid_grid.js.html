<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/app/dashboardView/grid/grid.js - ozpwebtop</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="ozpwebtop"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/apis.dashboardApi.html">apis.dashboardApi</a></li>
            
                <li><a href="../classes/apis.iwcDashboardApiImpl.html">apis.iwcDashboardApiImpl</a></li>
            
                <li><a href="../classes/apis.localStorageDashboardApiImpl.html">apis.localStorageDashboardApiImpl</a></li>
            
                <li><a href="../classes/apis.marketplaceApi.html">apis.marketplaceApi</a></li>
            
                <li><a href="../classes/apis.userSettingsApi.html">apis.userSettingsApi</a></li>
            
                <li><a href="../classes/components.ozpButton.html">components.ozpButton</a></li>
            
                <li><a href="../classes/dashboardView.GridCtrl.html">dashboardView.GridCtrl</a></li>
            
                <li><a href="../classes/dashboardView.IframeCtrl.html">dashboardView.IframeCtrl</a></li>
            
                <li><a href="../classes/dashboardView.ozpGridsterItem.html">dashboardView.ozpGridsterItem</a></li>
            
                <li><a href="../classes/dashboardView.ozpManagedFrame.html">dashboardView.ozpManagedFrame</a></li>
            
                <li><a href="../classes/general.dashboardChangeMonitor.html">general.dashboardChangeMonitor</a></li>
            
                <li><a href="../classes/general.elliptical.html">general.elliptical</a></li>
            
                <li><a href="../classes/general.Utiliites.html">general.Utiliites</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/ozpWebtopApp.html">ozpWebtopApp</a></li>
            
                <li><a href="../modules/ozpWebtopApp.apis.html">ozpWebtopApp.apis</a></li>
            
                <li><a href="../modules/ozpWebtopApp.appLauncher.html">ozpWebtopApp.appLauncher</a></li>
            
                <li><a href="../modules/ozpWebtopApp.appToolbar.html">ozpWebtopApp.appToolbar</a></li>
            
                <li><a href="../modules/ozpWebtopApp.components.html">ozpWebtopApp.components</a></li>
            
                <li><a href="../modules/ozpWebtopApp.constants.html">ozpWebtopApp.constants</a></li>
            
                <li><a href="../modules/ozpWebtopApp.dashboardToolbar.html">ozpWebtopApp.dashboardToolbar</a></li>
            
                <li><a href="../modules/ozpWebtopApp.dashboardView.html">ozpWebtopApp.dashboardView</a></li>
            
                <li><a href="../modules/ozpWebtopApp.general.html">ozpWebtopApp.general</a></li>
            
                <li><a href="../modules/ozpWebtopApp.ozpIwcClient.html">ozpWebtopApp.ozpIwcClient</a></li>
            
                <li><a href="../modules/ozpWebtopApp.userSettings.html">ozpWebtopApp.userSettings</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/app/dashboardView/grid/grid.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;

/**
 * GridCtrl retrieves the state of a number of tiles and binds it to an
 * Angular scope.
 *
 * @namespace dashboardView
 * @class GridCtrl
 * @constructor
 * @param {Object} $scope an Angular scope
 * @param {Object} $rootScope the Angular root scope
 * @param {Object} $location the Angular location service
 * @param {Object} dashboardApi the API for dashboard information
 * @param {Object} marketplaceApi the API for marketplace application information
 * @param {Object} dashboardChangeMonitor the service that monitors dashboard changes
 */
angular.module(&#x27;ozpWebtopApp.dashboardView&#x27;)

.controller(&#x27;GridCtrl&#x27;, function ($scope, $rootScope, $location,
                                        dashboardApi, marketplaceApi,
                                        dashboardChangeMonitor, userSettingsApi) {

    if(!$scope.dashboards){
      dashboardApi.getDashboards().then(function(dashboards) {
        $scope.dashboards = dashboards;
      }).catch(function(error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });
    }
    dashboardChangeMonitor.run();

    // The applications/widgets on the grid view
    $scope.frames = [];  // to make tests happy

    marketplaceApi.getAllApps().then(function(apps) {
      $scope.apps = apps;
    }).catch(function(error) {
      console.log(&#x27;should not have happened: &#x27; + error);
    });

    $scope.$on(&#x27;dashboard-change&#x27;, function() {
      // Make an array of old frames and new frames
      $scope.newFrames = [];
      $scope.oldFrames = [];
      var currentDashboard = dashboardChangeMonitor.dashboardId;

      dashboardApi.getDashboards().then(function(dashboards) {
        $scope.dashboards = dashboards;
        if ($scope.frames !== $scope.dashboards[currentDashboard].frames) {
          for (var i=0; i &lt; $scope.frames.length; i++) {
            $scope.oldFrames.push($scope.frames[i].appId);
          }
          for (var j=0; j &lt; $scope.dashboards[currentDashboard].frames.length; j++) {
            $scope.newFrames.push($scope.dashboards[currentDashboard].frames[j].appId);
          }

          // return just the differences between oldFrames and new Frames
          Array.prototype.diff = function(a) {
            // this
            return this.filter(function(i) {return a.indexOf(i) &lt; 0;});
          };

          // add or remove new frames without reloading the entire scope
          // if there are items in the currentScope that are not in the updated
          // scope from the service, remove theme here
          if ($scope.oldFrames.diff($scope.newFrames).length &gt; 0) {
            for (var a=0; a &lt; $scope.frames.length; a++) {
              // if the removed frame is present, splice it out of the local scope
              if ($scope.frames[a].appId === $scope.oldFrames.diff($scope.newFrames)[0]) {
                $scope.frames.splice(a, 1);
              }
            }
          }
          //if there are new frames for this dashboard on the services that are
          // not in the local scope
          if ($scope.newFrames.diff($scope.oldFrames).length &gt; 0) {
            // if the item from the dashboard api matches the new frame we found in
            // this view
            dashboardApi.getDashboardById(dashboardChangeMonitor.dashboardId).then(function(dashboard) {
              // TODO: for loop with async call inside, not good
              for (var c=0; c &lt; dashboard.frames.length; c++) {
                if (dashboard.frames[c].appId === $scope.newFrames.diff($scope.oldFrames)[0]) {
                  // push that frame to the local scope. since the changes are
                  // automatically bound with the view, no refresh required
                  $scope.frames.push(dashboard.frames[c]);
                  // update the frame size so it fits inside its little widget boundary
                  // TODO: this might not behave as expected
                  $scope.updateDashboardFramePx(dashboard.frames[c].id);
                  // now quickly merge my local scope for frames with the marketplace
                  // api to get important stuff on local scope like url, image, name,
                  // etc
                  dashboardApi.mergeApplicationData($scope.frames, $scope.apps);
                }
              }
            }).catch(function (error) {
              console.log(&#x27;should not have happened: &#x27; + error);
            });
          }
        }
      }).catch(function(error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });

    });


    $scope.$on(&#x27;userSettings-change&#x27;, function() {
      userSettingsApi.getUserSettings().then(function(settings) {
        if (settings.isAppboardHidden === true) {
          $scope.appBarHidden = true;
        } else {
          $scope.appBarHidden = false;
        }
      }).catch(function(error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });
    });

    // TODO: Originally tried sending broadcast events from dashboardChangeMonitor,
    // but that did not work out - led to lots of problems such as the desktop
    // and grid controllers not being loaded/unloaded properly. So instead, we&#x27;ll
    // just reach into the internal state of the dashboardChangeMonitor to get
    // this info and use $watch on $location.path to trigger the update. To
    // see what happens, just uncomment the console.logs in $on.(...) in
    // grid.js and desktop.js
    $scope.$watch(function() {
      return $location.path();
    }, function() {
      $scope.reloadDashboard().then(function() {
        // dashboard reloaded
      }).catch(function(error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });
    });

    /**
     *
     * Calculates the size of a frame, saves it, and sends a gridSizeChanged
     * message
     *
     * @param {String} frameId Id of the frame to update
     * @returns {Promise} fulfilled with boolean true if frame was updated
     *                    successfully
     */
    $scope.updateDashboardFramePx = function(frameId) {
      // the dimensions reported by uiWidget are wrong - use custom function
      // to calculate new size (pixels)
      var widgetSize = $scope.updateLocalGridFrameSize(frameId);
      // save the changes
      return dashboardApi.updateFrameSizeOnGrid(widgetSize.id, widgetSize.width,
        widgetSize.height).then(function(update) {
          if (!update) {
            console.log(&#x27;Error updating framesize on grid&#x27;);
          }

          $rootScope.$broadcast(&#x27;gridSizeChanged&#x27;, {
            &#x27;frameId&#x27;: widgetSize.id,
            &#x27;height&#x27;: widgetSize.height,
            &#x27;width&#x27;: widgetSize.width
          });

          // TODO: clean this up
          $rootScope.activeFrames = $scope.frames;

      }).catch(function(error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });
    };

    /**
     * Reloads the current dashboard
     * @returns {Promise} Promise fulfilled with Boolean, true if dashboard was
     *                    found
     */
    $scope.reloadDashboard = function() {
      // Get the dashboard
      $scope.dashboardId = dashboardChangeMonitor.dashboardId;
      return dashboardApi.getDashboardById($scope.dashboardId).then(function (dashboard) {
        if (!dashboard) {
          console.log(&#x27;Dashboard changed, but dashboard does not exist&#x27;);
          return;
        }
        $scope.dashboard = dashboard;
        // Get frames on this dashboard
        $scope.frames = $scope.dashboard.frames;

        // Merge application data (app name, icons, descriptions, url, etc)
        // with dashboard app data
        dashboardApi.mergeApplicationData($scope.frames, $scope.apps);

        // calculate the size (in px) for each frame and send an update message
        $scope.frames.reduce(function (previous, current) {
          return previous.then(function () {
            var promise = $scope.updateDashboardFramePx(current.id);
            return promise;
          }).catch(function (error) {
            console.log(&#x27;should not have happened: &#x27; + error);
          });
        }, Promise.resolve()).then(function () {
            // reloadDashboard completed
        });
      }).catch(function (error) {
        console.log(&#x27;should not have happened: &#x27; + error);
      });
    };

    /**
     * Update a single frame after a change (move or resize) has occurred
     * @param {Object} frame The frame to update
     * @returns {Promise} Promise fulfilled with the frame id that was updated
     */
    $scope.updateFrameAfterChange = function(frame) {
      // save the basic grid settings
      return dashboardApi.updateGridFrame(frame.id, frame.gridLayout.row,
        frame.gridLayout.col, frame.gridLayout.sizeX,
        frame.gridLayout.sizeY).then(function(frameId) {
          if (!frameId) {
            console.log(&#x27;ERROR: could not update grid frame&#x27;);
            return;
          }
          return $scope.updateDashboardFramePx(frameId);
        }).catch(function(error) {
          console.log(&#x27;should not have happened: &#x27; + error);
        });
    };

    /**
     * Update all frames after the user finishes moving or resizing a frame
     */
    $scope.updateAllFramesAfterChange = function() {
      var frames = $scope.frames;
      frames.reduce(function(previous, current) {
      return previous.then(function() {
        var promise = $scope.updateFrameAfterChange(current);
        return promise;
      });
      }, Promise.resolve()).then(function() {
        // finished updating all frames
      });
    };

    // TODO: broadcast a message with these grid options so other components
    // have access to the information

    // Gridster options/configuration
    $scope.gridOptions =  {
      columns: 6, // the width of the grid, in columns
      pushing: true, // whether to push other items out of the way on move or resize
      floating: true, // whether to automatically float items up so they stack (you can temporarily disable if you are adding unsorted items with ng-repeat)
      width: &#x27;auto&#x27;, // can be an integer or &#x27;auto&#x27;. &#x27;auto&#x27; scales gridster to be the full width of its containing element
      colWidth: &#x27;auto&#x27;, // can be an integer or &#x27;auto&#x27;.  &#x27;auto&#x27; uses the pixel width of the element divided by &#x27;columns&#x27;
      rowHeight: &#x27;match&#x27;, // can be an integer or &#x27;match&#x27;.  Match uses the colWidth, giving you square widgets.
      margins: [20, 20], // the pixel distance between each widget
      outerMargin: false, // don&#x27;t apply margins to outside of grid
      isMobile: false, // stacks the grid items if true
      minColumns: 1, // the minimum columns the grid must have
      minRows: 1, // the minimum height of the grid, in rows
      maxRows: 10,
      resizable: {
        enabled: true,
        handles: &#x27;n, e, s, w, ne, se, sw, nw&#x27;,
        start: function(event, uiWidget) {
          // reduce the size of the frame when resizing is started so that
          // gridster behaves itself
          var frameId = uiWidget.element.context.id;
          for (var i=0; i &lt; $scope.frames.length; i++) {
            if ($scope.frames[i].id === frameId) {
              // trying to do something smarter here didn&#x27;t work out well - be
              // sure to perform ample testing if these values are changed
              $scope.frames[i].gridLayout.width = 100;
              $scope.frames[i].gridLayout.height = 100;

              $rootScope.$broadcast(&#x27;gridSizeChanged&#x27;, {
                &#x27;frameId&#x27;: frameId,
                &#x27;height&#x27;: 100,
                &#x27;width&#x27;: 100
              });
            }
          }
        }, // optional callback fired when resize is started,
        resize: function(/*event, uiWidget, $element */) {
        }, // optional callback fired when item is resized,
        stop: function(/*event, uiWidget*/){
          $scope.updateAllFramesAfterChange();
        } // optional callback fired when item is finished resizing
      },
      draggable: {
        enabled: true, // whether dragging items is supported
        handle: &#x27;div.ozp-chrome, div.ozp-chrome &gt; .chrome-icon, div.ozp-chrome &gt; .chrome-name&#x27;, // optional selector for resize handle
        start: function(/*event, uiWidget, $element*/) {}, // optional callback fired when drag is started,
        drag: function(/*event, uiWidget, $element*/) {}, // optional callback fired when item is moved,
        stop: function(/*event, uiWidget, $element*/) {
          $scope.updateAllFramesAfterChange();
        } // optional callback fired when item is finished dragging
      }
    };

    /**
     * Calculates the size in pixels for a given frame
     * Necessary because the built-in angular-gridster method that calculates a
     * grid tile&#x27;s size after resizing does not yield the correct results.
     *
     * Notes:
     *  hard-coded value of gridster container padding
     *  accesses $scope.gridOptions
     *
     *
     * @param {Object} frame The frame for which to calculate size
     * @returns {Object} height and width
     */
    $scope.calculateGridFrameSize = function(frame) {
      // determine container properties

      // padding on left and right sides of container
      var gridsterContainerPadding = 15;
      var cols = $scope.gridOptions.columns;
      var windowWidth = window.innerWidth;
      var colMargin = $scope.gridOptions.margins[0];
      var totalWorkingWidth = windowWidth - 2*gridsterContainerPadding -
        (cols-1)*colMargin;
      var baseWidgetWidth = totalWorkingWidth/cols;
      // assume row margins and height are same as for columns
      var baseWidgetHeight = baseWidgetWidth;

      // now take the frame into account
      var sizeX = frame.gridLayout.sizeX;
      var sizeY = frame.gridLayout.sizeY;
      var widgetWidth = baseWidgetWidth * sizeX + (colMargin*(sizeX-1));
      // Make small adjustment to width
      widgetWidth -= 2*sizeX;
      var widgetHeight = baseWidgetHeight * sizeY + (colMargin*(sizeY-1));
      return {
        &#x27;height&#x27;: widgetHeight,
        &#x27;width&#x27;: widgetWidth
      };
    };

    /**
     * Update the widget&#x27;s pixel size on the grid (this update is local, the
     * data is not persisted to the dashboard api)
     *
     * @param {String} frameId The id of the frame for which to update size
     * @returns {Object} widget size (height and width) and the frame id
     */
    $scope.updateLocalGridFrameSize = function(frameId) {
      for (var i = 0; i &lt; $scope.frames.length; i++) {
        if ($scope.frames[i].id === frameId) {
          var widgetSize = $scope.calculateGridFrameSize($scope.frames[i]);
          widgetSize.width -= 10;   // for good measure
          widgetSize.height -= 30;  // minus height of chrome
          widgetSize.id = frameId;
          $scope.frames[i].gridLayout.width = widgetSize.width;
          $scope.frames[i].gridLayout.height = widgetSize.height;
          return widgetSize;
        }
      }
    };

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
